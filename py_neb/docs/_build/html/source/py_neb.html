
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>py_neb package &#8212; PyNEB  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyNEB  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">py_neb package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="py-neb-package">
<h1>py_neb package<a class="headerlink" href="#py-neb-package" title="Permalink to this headline">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-py_neb.fileio">
<span id="py-neb-fileio-module"></span><h2>py_neb.fileio module<a class="headerlink" href="#module-py_neb.fileio" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="py_neb.fileio.DijkstraLogger">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.fileio.</span></span><span class="sig-name descname"><span class="pre">DijkstraLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">djkInst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.fileio.DijkstraLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.fileio.DijkstraLogger.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variableNames</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.fileio.DijkstraLogger.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.fileio.ForceLogger">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.fileio.</span></span><span class="sig-name descname"><span class="pre">ForceLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classInst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loggerSettings</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.fileio.ForceLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.fileio.ForceLogger.flush">
<span class="sig-name descname"><span class="pre">flush</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.fileio.ForceLogger.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Note that this must be called, as the self.log only writes the data in
chunks. Any data falling outside of those chunks will be stored in
self.logDict, but not written.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variables</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>variableNames</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.fileio.ForceLogger.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variablesDict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.fileio.ForceLogger.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.fileio.LoadDijkstraLog">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.fileio.</span></span><span class="sig-name descname"><span class="pre">LoadDijkstraLog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.fileio.LoadDijkstraLog" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.fileio.LoadForceLog">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.fileio.</span></span><span class="sig-name descname"><span class="pre">LoadForceLog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.fileio.LoadForceLog" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.fileio.VerletLogger">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.fileio.</span></span><span class="sig-name descname"><span class="pre">VerletLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vltInst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logLevel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.fileio.VerletLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

</section>
<section id="module-py_neb.solvers">
<span id="py-neb-solvers-module"></span><h2>py_neb.solvers module<a class="headerlink" href="#module-py_neb.solvers" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="py_neb.solvers.Dijkstra">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.solvers.</span></span><span class="sig-name descname"><span class="pre">Dijkstra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initialPoint,</span> <span class="pre">coordMeshTuple,</span> <span class="pre">potArr,</span> <span class="pre">inertArr=None,</span> <span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.action&gt;,</span> <span class="pre">allowedEndpoints=None,</span> <span class="pre">trimVals=[0.0001,</span> <span class="pre">None],</span> <span class="pre">logLevel=1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.Dijkstra" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.Dijkstra.minimum_endpoint">
<span class="sig-name descname"><span class="pre">minimum_endpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distanceDict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.Dijkstra.minimum_endpoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.solvers.EulerLagrangeSolver">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.solvers.</span></span><span class="sig-name descname"><span class="pre">EulerLagrangeSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initialPath</span></em>, <em class="sig-param"><span class="pre">eneg_func</span></em>, <em class="sig-param"><span class="pre">mass_func=None</span></em>, <em class="sig-param"><span class="pre">grad_approx=&lt;function</span> <span class="pre">midpoint_grad&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.EulerLagrangeSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.EulerLagrangeSolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.EulerLagrangeSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.solvers.EulerLagrangeVerification">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.solvers.</span></span><span class="sig-name descname"><span class="pre">EulerLagrangeVerification</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path</span></em>, <em class="sig-param"><span class="pre">enegOnPath</span></em>, <em class="sig-param"><span class="pre">eneg_func</span></em>, <em class="sig-param"><span class="pre">massOnPath=None</span></em>, <em class="sig-param"><span class="pre">mass_func=None</span></em>, <em class="sig-param"><span class="pre">grad_approx=&lt;function</span> <span class="pre">midpoint_grad&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.EulerLagrangeVerification" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.EulerLagrangeVerification.compare_lagrangian">
<span class="sig-name descname"><span class="pre">compare_lagrangian</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.EulerLagrangeVerification.compare_lagrangian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.EulerLagrangeVerification.compare_lagrangian_squared">
<span class="sig-name descname"><span class="pre">compare_lagrangian_squared</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.EulerLagrangeVerification.compare_lagrangian_squared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.solvers.LeastActionPath">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.solvers.</span></span><span class="sig-name descname"><span class="pre">LeastActionPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">potential</span></em>, <em class="sig-param"><span class="pre">nPts</span></em>, <em class="sig-param"><span class="pre">nDims</span></em>, <em class="sig-param"><span class="pre">mass=None</span></em>, <em class="sig-param"><span class="pre">endpointSpringForce=True</span></em>, <em class="sig-param"><span class="pre">endpointHarmonicForce=True</span></em>, <em class="sig-param"><span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.action&gt;</span></em>, <em class="sig-param"><span class="pre">target_func_grad=&lt;bound</span> <span class="pre">method</span> <span class="pre">GradientApproximations.forward_action_grad</span> <span class="pre">of</span> <span class="pre">&lt;utilities.GradientApproximations</span> <span class="pre">object&gt;&gt;</span></em>, <em class="sig-param"><span class="pre">nebParams={}</span></em>, <em class="sig-param"><span class="pre">logLevel=1</span></em>, <em class="sig-param"><span class="pre">loggerSettings={}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.LeastActionPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>class documentation…?</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.LeastActionPath.compute_force">
<span class="sig-name descname"><span class="pre">compute_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.LeastActionPath.compute_force" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.solvers.MinimumEnergyPath">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.solvers.</span></span><span class="sig-name descname"><span class="pre">MinimumEnergyPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">potential</span></em>, <em class="sig-param"><span class="pre">nPts</span></em>, <em class="sig-param"><span class="pre">nDims</span></em>, <em class="sig-param"><span class="pre">endpointSpringForce=True</span></em>, <em class="sig-param"><span class="pre">endpointHarmonicForce=True</span></em>, <em class="sig-param"><span class="pre">auxFunc=None</span></em>, <em class="sig-param"><span class="pre">target_func=&lt;function</span> <span class="pre">TargetFunctions.mep_default&gt;</span></em>, <em class="sig-param"><span class="pre">target_func_grad=&lt;function</span> <span class="pre">potential_central_grad&gt;</span></em>, <em class="sig-param"><span class="pre">nebParams={}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.MinimumEnergyPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Eric</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.MinimumEnergyPath.compute_force">
<span class="sig-name descname"><span class="pre">compute_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.MinimumEnergyPath.compute_force" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.solvers.VerletMinimization">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.solvers.</span></span><span class="sig-name descname"><span class="pre">VerletMinimization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nebObj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initialPoints</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.VerletMinimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.VerletMinimization.fire">
<span class="sig-name descname"><span class="pre">fire</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tStep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fireParams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useLocal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.VerletMinimization.fire" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for fast inertial relaxation engine.
FIRE step taken from <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.97.170201">http://dx.doi.org/10.1103/PhysRevLett.97.170201</a></p>
<p>Velocity update taken from
<a class="reference external" href="https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet">https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet</a></p>
<p>TODO: consider making FIRE its own class, or allowing for attributes
like fireParams and etc
TODO: add maxmove parameter to prevent path exploding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tStep</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>maxIters</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>fireParams</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is {}.</p></li>
<li><p><strong>useLocal</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.VerletMinimization.velocity_verlet">
<span class="sig-name descname"><span class="pre">velocity_verlet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tStep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dampingParameter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.VerletMinimization.velocity_verlet" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements Algorithm 6 of <a class="reference external" href="https://doi.org/10.1021/acs.jctc.7b00360">https://doi.org/10.1021/acs.jctc.7b00360</a>
with optional damping force.</p>
<p>TODO: that paper has many errors, esp. off-by-one errors. Could lead
to issues. Consult <a class="reference external" href="http://dx.doi.org/10.1063/1.2841941">http://dx.doi.org/10.1063/1.2841941</a> instead.
TODO: modify to edit self.allPts and etc</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tStep</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>maxIters</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>dampingParameter</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>allPts</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>allVelocities</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>allForces</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.solvers.VerletMinimization_newAPI">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.solvers.</span></span><span class="sig-name descname"><span class="pre">VerletMinimization_newAPI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nebObj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initialPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optArgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.VerletMinimization_newAPI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.VerletMinimization_newAPI.fire">
<span class="sig-name descname"><span class="pre">fire</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tStep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fireParams</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useLocal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.VerletMinimization_newAPI.fire" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for fast inertial relaxation engine.
FIRE step taken from <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.97.170201">http://dx.doi.org/10.1103/PhysRevLett.97.170201</a></p>
<p>Velocity update taken from
<a class="reference external" href="https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet">https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet</a></p>
<p>TODO: consider making FIRE its own class, or allowing for attributes
like fireParams and etc
TODO: add maxmove parameter to prevent path exploding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tStep</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>maxIters</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>fireParams</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is {}.</p></li>
<li><p><strong>useLocal</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.solvers.VerletMinimization_newAPI.velocity_verlet">
<span class="sig-name descname"><span class="pre">velocity_verlet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tStep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxIters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dampingParameter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.solvers.VerletMinimization_newAPI.velocity_verlet" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements Algorithm 6 of <a class="reference external" href="https://doi.org/10.1021/acs.jctc.7b00360">https://doi.org/10.1021/acs.jctc.7b00360</a>
with optional damping force.</p>
<p>TODO: that paper has many errors, esp. off-by-one errors. Could lead
to issues. Consult <a class="reference external" href="http://dx.doi.org/10.1063/1.2841941">http://dx.doi.org/10.1063/1.2841941</a> instead.
TODO: modify to edit self.allPts and etc</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tStep</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>maxIters</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>dampingParameter</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>allPts</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>allVelocities</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>allForces</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-py_neb.utilities">
<span id="py-neb-utilities-module"></span><h2>py_neb.utilities module<a class="headerlink" href="#module-py_neb.utilities" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="py_neb.utilities.GradientApproximations">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">GradientApproximations</span></span><a class="headerlink" href="#py_neb.utilities.GradientApproximations" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.GradientApproximations.discrete_action_grad">
<span class="sig-name descname"><span class="pre">discrete_action_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.GradientApproximations.discrete_action_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs discretized action gradient, needs numerical PES still</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.GradientApproximations.discrete_element">
<span class="sig-name descname"><span class="pre">discrete_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradOfPes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beffp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beffm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potm1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.GradientApproximations.discrete_element" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mass</strong> (<em>function</em>) – Callable mass function</p></li>
<li><p><strong>path</strong> (<em>float</em>) – Point i</p></li>
<li><p><strong>gradOfPes</strong> (<em>float array</em>) – Gradient of PES at point i</p></li>
<li><p><strong>dr</strong> (<em>float array</em>) – dr = r_i - r_i-1</p></li>
<li><p><strong>drp1</strong> (<em>float array</em>) – drp1 = r_i+1 - r_i</p></li>
<li><p><strong>beff</strong> (<em>float</em>) – Effective mass at point i</p></li>
<li><p><strong>beffp1</strong> (<em>float</em>) – Effective mass at point i+1</p></li>
<li><p><strong>beffm1</strong> (<em>float</em>) – Effective mass at point i-1</p></li>
<li><p><strong>pot</strong> (<em>float</em>) – Potential at point i.</p></li>
<li><p><strong>potp1</strong> (<em>float</em>) – Potential at point i+1</p></li>
<li><p><strong>potm1</strong> (<em>float</em>) – Potential at point i-1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gradOfAction</strong> (<em>float array</em>) – Gradient of action at point i</p></li>
<li><p><em>Maintainer: Kyle</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.GradientApproximations.discrete_sqr_action_grad">
<span class="sig-name descname"><span class="pre">discrete_sqr_action_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.GradientApproximations.discrete_sqr_action_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs discretized action gradient, needs numerical PES still</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.GradientApproximations.discrete_sqr_action_grad_mp">
<span class="sig-name descname"><span class="pre">discrete_sqr_action_grad_mp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.GradientApproximations.discrete_sqr_action_grad_mp" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs discretized action gradient, needs numerical PES still</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.GradientApproximations.forward_action_component_grad">
<span class="sig-name descname"><span class="pre">forward_action_component_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.GradientApproximations.forward_action_component_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Requires an approximation of the action that just sums up values along
the path, such as TargetFunctions.action. Then, this computes the
forwards finite difference approximation of every <em>term in the sum</em>.</p>
<p>Note the difference with GradientApproximations().forward_action_grad:
there, the full action is computed for every step. Here, only the component
at that step is computed.</p>
<p>Does not return the gradient of the mass function, as that’s not used
elsewhere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>ndarray</em>) – The path. Of shape (nPoints,nDims)</p></li>
<li><p><strong>potential</strong> (<em>function.</em>) – Must take as input an array of shape path.shape</p></li>
<li><p><strong>potentialOnPath</strong> (<em>ndarray</em>) – Potential on the path. Of shape (nPoints,).</p></li>
<li><p><strong>mass</strong> (<em>function</em><em> or </em><em>None</em>) – </p></li>
<li><p><strong>massOnPath</strong> (<em>ndarray</em><em> or </em><em>None</em>) – Mass on path. If not None, of shape (nPoints,nDims,nDims).</p></li>
<li><p><strong>target_func</strong> (<em>function</em>) – Any term in TargetFunctions that is the sum of some constituent
terms (e.g. TargetFunctions.action). Uses target_func.__name__
to select the gradient of a term in the sum, such as
TargetFunctions.term_in_action_sum</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gradOfAction</strong> (<em>ndarray</em>)</p></li>
<li><p><strong>gradOfPes</strong> (<em>ndarray</em>)</p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.GradientApproximations.forward_action_grad">
<span class="sig-name descname"><span class="pre">forward_action_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potentialOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">massOnPath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.GradientApproximations.forward_action_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes forwards finite difference approx of any action-like function.
See e.g. TargetFunctions.action. Note that the full action is computed
at every finite difference step.</p>
<p>Does not return the gradient of the mass function, as that’s not used
elsewhere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>ndarray</em>) – The path. Of shape (nPoints,nDims)</p></li>
<li><p><strong>potential</strong> – As allowed in TargetFunctions.action</p></li>
<li><p><strong>potentialOnPath</strong> (<em>ndarray</em>) – Potential on the path. Of shape (nPoints,).</p></li>
<li><p><strong>mass</strong> – As allowed in TargetFunctions.action</p></li>
<li><p><strong>massOnPath</strong> (<em>ndarray</em><em> or </em><em>None</em>) – Mass on path. If not None, of shape (nPoints,nDims,nDims).</p></li>
<li><p><strong>target_func</strong> (<em>function</em>) – Function whose gradient is being computed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gradOfAction</strong> (<em>ndarray</em>)</p></li>
<li><p><strong>gradOfPes</strong> (<em>ndarray</em>)</p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.utilities.InterpolatedPath">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">InterpolatedPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretePath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.InterpolatedPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.InterpolatedPath.compute_along_path">
<span class="sig-name descname"><span class="pre">compute_along_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nImages</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tfArgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tfKWargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.InterpolatedPath.compute_along_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.utilities.NDInterpWithBoundary">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">NDInterpWithBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridPoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gridVals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaryHandler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'exponential'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmExtend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splKWargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.NDInterpWithBoundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interpolates a grid in D dimensions, with extra handling for points outside
of the grid. The D&gt;2 case is based on scipy.interpolate.RegularGridInterpolator</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.utilities.RectBivariateSplineWrapper">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">RectBivariateSplineWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.RectBivariateSplineWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.interpolate.fitpack2.RectBivariateSpline</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.RectBivariateSplineWrapper.func_wrapper">
<span class="sig-name descname"><span class="pre">func_wrapper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.RectBivariateSplineWrapper.func_wrapper" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.utilities.SurfaceUtils">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">SurfaceUtils</span></span><a class="headerlink" href="#py_neb.utilities.SurfaceUtils" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Defined for namespace purposes</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.SurfaceUtils.find_all_local_minimum">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">find_all_local_minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.SurfaceUtils.find_all_local_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices corresponding to the local minimum values. Taken
originally from <a class="reference external" href="https://stackoverflow.com/a/3986876">https://stackoverflow.com/a/3986876</a></p>
<p>Finder checks along the cardinal directions. If all neighbors in those
directions are greater than or equal to the current value, the index
is returned as a minimum. For the border, the array is reflected about
the axis. As a result, many indices are found that are not technically
local minima. However, we do want the border results - in practice,
nuclei often have a ground state at zero deformation in one collective
coordinate; to find that, we must include the border indices. To exclude
them, one can then call SurfaceUtils.find_local_minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> (<em>Numpy array</em>) – A D-dimensional array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>minIndsOut</strong> – D arrays of length k, for k minima found</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple of numpy arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.SurfaceUtils.find_approximate_contours">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">find_approximate_contours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordMeshTuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eneg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.SurfaceUtils.find_approximate_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds 2D contours on a D-dimensional surface. Does so by considering
2D surfaces, using the first 2 indices of zz, and iterating over all other
indices. At every set of indices, pyplot.contour is called, to get the
2D contour(s) on the surface at that level. The contours are not filled
with the value of the coordinates with the other indices - i.e. each
segment is of shape (k,2), regardless of the number of dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coordMeshTuple</strong> (<em>tuple of ndarray</em>) – Coordinate mesh, e.g. output of np.meshgrid</p></li>
<li><p><strong>zz</strong> (<em>ndarray</em>) – Potential on mesh</p></li>
<li><p><strong>eneg</strong> (<em>float</em><em>, </em><em>optional</em>) – Energy of the desired contour. The default is 0.</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to plot the contours. The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – Does not work for 1 dimension.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>allContours</strong> – Each element is the returned value of ax.contour.allsegs[0], i.e.
a list consisting of 2D arrays describing the contour on that slize
of zz</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray of lists</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.SurfaceUtils.find_endpoints_on_grid">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">find_endpoints_on_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordMeshTuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potArr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnAllPoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eneg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.SurfaceUtils.find_endpoints_on_grid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>returnAllPoints</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is False.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>allowedEndpoints</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>TYPE</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.SurfaceUtils.find_local_minimum">
<span class="sig-name descname"><span class="pre">find_local_minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">searchPerc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.25,</span> <span class="pre">0.25]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returnOnlySmallest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.SurfaceUtils.find_local_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices corresponding to the local minimum values within a
desired part of the PES.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>Numpy array</em>) – A D-dimensional array.</p></li>
<li><p><strong>searchPerc</strong> (<em>List</em>) – Percentage of each coordinate that the minimum is allowed to be in.
See Notes for a note on searchPerc</p></li>
<li><p><strong>returnOnlySmallest</strong> (<em>Bool. Default is True</em>) – If True, returns only the (first) smallest value. If False, returns
all minima in the searched region.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>minIndsOut</strong> – D arrays of length k, for k minima found in the region. If returnOnlySmallest,
returns a tuple, not a tuple of arrays</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple of numpy arrays</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Note that, if we write searchPerc=[s1,s2], then s1 is the range for
the first coordinate of arr. If arr was constructed to agree with
np.meshgrid’s default indexing, then s1 will actually restrict the
range of the second (physical) coordinate: np.meshgrid(X,Y,Z,…)
returns arrays of shape (Y.len,X.len,Z.len,…)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.SurfaceUtils.round_points_to_grid">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">round_points_to_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordMeshTuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptsArr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.SurfaceUtils.round_points_to_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds an array of points to the nearest point on a grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coordMeshTuple</strong> (<em>tuple of ndarrays</em>) – The grid. Taken as output of np.meshgrid</p></li>
<li><p><strong>ptsArr</strong> (<em>ndarray</em>) – The points to round. Of shape (nPoints,nDims), where nDims is the
number of coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>indsOut</strong> (<em>ndarray of ints</em>) – The indices of the points. Of shape (nPoints,nDims). See notes.</p></li>
<li><p><strong>gridValsOut</strong> (<em>ndarray</em>) – The nearest grid values. Of shape (nPoints,nDims).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Has standard complication from np.meshgrid - indexing is (N2,N1,N3,…),
when the coordinates have lengths (N1,N2,N3,…). This assumes the default
indexing of np.meshgrid for coordMeshTuple, but the returned indices are
in order (N1,N2,N3,…) (at the moment). TODO: change this?</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="py_neb.utilities.TargetFunctions">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">TargetFunctions</span></span><a class="headerlink" href="#py_neb.utilities.TargetFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.TargetFunctions.action">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">action</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.TargetFunctions.action" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: docs
Allowed masses:</p>
<blockquote>
<div><p>-Constant mass; set masses = None
-Array of values; set masses to a numpy array of shape (nPoints, nDims, nDims)
-A function; set masses to a function</p>
</div></blockquote>
<dl class="simple">
<dt>Allowed potential:</dt><dd><p>-Array of values; set potential to a numpy array of shape (nPoints,)
-A function; set masses to a function</p>
</dd>
<dt>Computes action as</dt><dd><p>$ S = sum_{i=1}^{nPoints} sqrt{2 E(x_i) M_{ab}(x_i) (x_i-x_{i-1})^a(x_i-x_{i-1})^b} $</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.TargetFunctions.action_squared">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">action_squared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.TargetFunctions.action_squared" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>ndarray</em>) – np.ndarray of shape (Nimgs,nDim) containing postions of all images.</p></li>
<li><p><strong>potential</strong> (<em>object</em><em> or </em><em>ndarray</em>) – Allowed potential:
-Array of values; set potential to a numpy array of shape (nPoints,)
-A function; set masses to a function</p></li>
<li><p><strong>masses</strong> (<em>object</em><em> or </em><em>ndarray</em><em>, </em><em>Optional</em>) – Allowed masses:
-Constant mass; set masses = None
-Array of values; set masses to a numpy array of shape (nPoints, nDims, nDims)
-A function; set masses to a function</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>actOut</strong> (<em>float</em>)</p></li>
<li><p><strong>potArr</strong> (<em>ndarray</em>) – ndarray of shape (Nimgs,1) containing the PES values for each image in path</p></li>
<li><p><strong>massArr</strong> (<em>ndarray</em>) – ndarray of shape (Nimgs,nDim,nDim) containing the mass tensors for each image in path.</p></li>
<li><p><em>Maintainer: Eric</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.TargetFunctions.mep_default">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">mep_default</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxFunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.TargetFunctions.mep_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Essentially a wrapper function for the potential. Expected points to be
a (nPts,nDim) matrix. Potential should be a function capable of returning
a (nPts,nDim) matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>potential</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>auxFunc</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – DESCRIPTION.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>energies</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>auxEnergies</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><em>Maintainer: Eric</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="py_neb.utilities.TargetFunctions.term_in_action_sum">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">term_in_action_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.TargetFunctions.term_in_action_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: docs
Allowed masses:</p>
<blockquote>
<div><p>-Constant mass; set masses = None
-Array of values; set masses to a numpy array of shape (nPoints, nDims, nDims)
-A function; set masses to a function</p>
</div></blockquote>
<dl class="simple">
<dt>Allowed potential:</dt><dd><p>-Array of values; set potential to a numpy array of shape (nPoints,)
-A function; set masses to a function</p>
</dd>
<dt>Computes action as</dt><dd><p>$ S = sum_{i=1}^{nPoints} sqrt{2 E(x_i) M_{ab}(x_i) (x_i-x_{i-1})^a(x_i-x_{i-1})^b} $</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Daniel</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="py_neb.utilities.beff_grad">
<span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">beff_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.beff_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Midpoint finite difference of B_eff mass.</p>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Kyle</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="py_neb.utilities.mass_funcs_to_array_func">
<span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">mass_funcs_to_array_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictOfFuncs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uniqueKeys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.mass_funcs_to_array_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats a collection of functions for use in computing the inertia tensor.
Assumes the inertia tensor is symmetric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dictOfFuncs</strong> (<em>dict</em>) – Contains functions for each component of the inertia tensor</p></li>
<li><p><strong>uniqueKeys</strong> (<em>list</em>) – <p>Labels the unique coordinates of the inertia tensor, in the order they
are used in the inertia. For instance, if one uses (q20, q30) as the
coordinates in this order, one should feed in [‘20’,’30’], and the
inertia will be reshaped as</p>
<blockquote>
<div><dl class="simple">
<dt>[[M_{20,20}, M_{20,30}]</dt><dd><p>[M_{30,20}, M_{30,30}]].</p>
</dd>
</dl>
</div></blockquote>
<p>Contrast this with feeding in [‘30’,’20’], in which the inertia will
be reshaped as</p>
<blockquote>
<div><dl class="simple">
<dt>[[M_{30,30}, M_{30,20}]</dt><dd><p>[M_{20,30}, M_{20,20}]].</p>
</dd>
</dl>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>func_out</strong> (<em>function</em>) – The inertia tensor. Can be called as func_out(coords).</p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="py_neb.utilities.midpoint_grad">
<span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">midpoint_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.midpoint_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: allow for arbitrary shaped outputs, for use with inertia tensor
TODO: maybe only have one gradient approx ever</p>
<dl class="simple">
<dt>Midpoint finite difference. Probably best if not used with actual DFT calculations,</dt><dd><p>vs a forwards/reverse finite difference</p>
</dd>
<dt>Assumes func only depends on a single point (vs the action, which depends on</dt><dd><p>all of the points)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Maintainer</dt>
<dd class="field-odd"><p>Eric</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="py_neb.utilities.potential_central_grad">
<span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">potential_central_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxFunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.potential_central_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in MEP for force updates. There, one only needs the gradient of the
PES.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>potential</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>auxFunc</strong> (<em>TYPE</em><em>, </em><em>optional</em>) – DESCRIPTION. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>gradPES</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><strong>gradAux</strong> (<em>TYPE</em>) – DESCRIPTION.</p></li>
<li><p><em>Maintainer: Eric</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="py_neb.utilities.shift_func">
<span class="sig-prename descclassname"><span class="pre">py_neb.utilities.</span></span><span class="sig-name descname"><span class="pre">shift_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#py_neb.utilities.shift_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts func_in output down by shift. Especially for use with interpolators
where the minimum of the interpolator may be a bit lower than the minimum of
the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func_in</strong> (<em>function</em>) – </p></li>
<li><p><strong>shift</strong> (<em>float</em>) – The amount to shift by. The default is 10**(-4).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>func_out</strong> (<em>function</em>) – The shifted function</p></li>
<li><p><em>Maintainer: Daniel</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-py_neb">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-py_neb" title="Permalink to this headline">¶</a></h2>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">py_neb package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-py_neb.fileio">py_neb.fileio module</a></li>
<li><a class="reference internal" href="#module-py_neb.solvers">py_neb.solvers module</a></li>
<li><a class="reference internal" href="#module-py_neb.utilities">py_neb.utilities module</a></li>
<li><a class="reference internal" href="#module-py_neb">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/py_neb.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyNEB  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">py_neb package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021 PyNEB Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>